// Author: Etay Hay, 2011
//    Models of Neocortical Layer 5b Pyramidal Cells Capturing a Wide Range of
//    Dendritic and Perisomatic Active Properties
//    (Hay et al., PLoS Computational Biology, 2011)
//
// Model of L5 Pyramidal Cell, constrained both for BAC firing and Current Step Firing


// Copied and adapted some needed functions to work with LFPy from file
// models/L5PCtemplate.hoc
//
// 30.01.2012 ehagen@umb.no

// Fixed problem of looping over the section lists
//
// 08.06.2012 ehagen@umb.no

// Copied and adapted from file hay/hay_active_declarations.py in the python package provided in
// Miceli, Ness, Einevoll, Schubert (2017) Impedance Spectrum in Cortical Tissue:
// Implications for Propagation of LFP Signals on the Microscopic Level.  Eneuro 4:1-15.
//
// May 13, 2020 bherr035@fiu.edu

objref this


proc geom_nseg() {local nSec, L1, L2, D1, D2, nSeg1, nSeg2
  soma area(.5) // make sure diam reflects 3d points
  nSec = 0
  forsec all {
    nseg = 1 + 2*int(L/40)
    nSec = nSec + 1
  }

  nSecAll = nSec
  nSec = 0
  soma { nSec = nSec + 1}
  nSecSoma	= 	nSec
  nSec = 0
  apic { nSec = nSec + 1}
  nSecApical= 	nSec
  nSec = 0
  dend { nSec = nSec + 1}
  nSecBasal	= 	nSec
  nSec = 0
  axon { nSec = nSec + 1}
  nSecAxonalOrig = nSecAxonal	= 	nSec
}


proc distribute_channels()	{local dist,val,base,maxLength
	base = $8
	soma distance()
	maxLength = getLongestBranch($s1)

	forsec $s1		{
		if(0==strcmp($s2,"Ra")){
			Ra = $8
		} else {
			for(x) {
				if ($3==3) {
					dist = distance(x)
				} else {
					dist = distance(x)/maxLength
				}
				val = calculate_distribution($3,dist,$4,$5,$6,$7,$8)
				sprint(tstr,"%s(%-5.10f) = %-5.10f",$s2,x,val)
				execute(tstr)
			}
		}
	}
}


// $s1 section
func getLongestBranch(){local maxL,d localobj distallist,sref
    sprint(tstr,"%s distance()",$s1)
    execute(tstr,this)

  	if(0==strcmp($s1,"axon")){
            sprint(tstr,"%s[0] distance(1)",$s1)
            execute(tstr,this)
  	}
		maxL = 0
		d = 0
		distallist = new SectionList()
		forsec $s1 {
			sref = new SectionRef()
			if (sref.nchild==0) distallist.append()
		}
		forsec distallist{
			d = distance(1)
			if(maxL<d) maxL = d
		}
		// for the soma case
		if (maxL == 0) {
      $s1 {
        maxL = L
      }
    }
		return maxL
}

// $1 is the distribution type:
//     0 linear, 1 sigmoid, 2 exponential
//     3 step for absolute distance (in microns)
func calculate_distribution()	{local value
	if ($1==0)	{value = $3 + $2*$4}
	if ($1==1) {value = $3 + ($4/(1+exp(($2-$5)/$6)))}
  	if ($1==2) {value = $3 + $6*exp($4*($2-$5))}
	if ($1==3) {
		if (($2 > $5) && ($2 < $6)) {
			value = $3
		} else {
			value = $4
		}
	}
	value = value*$7
	return value
}

// deleting axon, keeping only first 60 micrometers
proc delete_axon(){
    axon {delete_section()}
    create axon[2]
    access axon[0]{
      L= 30
      diam = 1
      nseg = 1+2*int(L/40)
    }
    access axon[1]{
      L= 30
      diam = 1
      nseg = 1+2*int(L/40)
    }

  nSecAxonal = 2
  connect axon(0), soma(0.5)
  connect axon[1](0), axon[0](1)
  access soma
}

// $s1 section
 // $2 distance x in micrometers
 // return list of [1,2] vectors  - of the appropriate section and the location in each vector
 obfunc locateSites() {local maxL,site,d0,d1,siteX,i localobj vv,ll
 	ll = new List()
 
     sprint(tstr,"%s distance()",$s1)
     execute(tstr,this)    
     
 	if(0==strcmp($s1,"axon")){
     sprint(tstr,"%s[0] distance(1)",$s1)
     execute(tstr,this)    
 	}
 
 	maxL = getLongestBranch($s1)

 	site = $2
 	i = 0
 	forsec $s1 {
     if (distance(0) < distance(1)) {
   		d0 = distance(0)
   		d1 = distance(1)
   	} else {
   		d1 = distance(0)
   		d0 = distance(1)
   	}
     if (site <= d1 && site >= d0) {
       //print $2
       siteX = (site-d0)/(d1-d0)
       //print siteX
       secNum = i
       //print secNum
       vv = new Vector()
       ll.append(vv.append(secNum,siteX))
 	}
 	i = i+1
 	}
    return ll
}